`timescale 1ns / 1ps

module rom (
    input  logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:127];
    assign data = rom[addr[31:2]];//0 4 8 16을 0,1,2,3으로 바꿔주기 위해 2비트 시프트

    initial begin
        $readmemh("code.mem",rom);

        // // //          _imm    842           _rd   _opcode;           -J_Type
        // rom[0]  = 32'b0_0000100110_0_00000000_11111_1101111;    // J-Type: JAL x31, offset
        // rom[1]  = 32'b0_0000100110_0_00000000_11111_1101111;    // J-Type: JAL x31, offset
        // rom[19] = 32'b111111111100_00010_000_00010_0010011;     // I-Type: ADDI x2, x2, -4
        // rom[20] = 32'b0000000_00101_00010_010_10000_0100011;    // S-Type: SW x5, offset(x2)
        // rom[21] = 32'b0000000_00110_00010_010_01000_0100011;    // S-Type: SW x6, offset(x2)
        // rom[22] = 32'b0000000_10100_00010_010_00000_0100011;    // S-Type: SW x20, offset(x2)
        // rom[23] = 32'b0000000_01011_01010_000_00101_0110011;    // R-Type: ADD x5, x10, x11
        // rom[24] = 32'b0000000_01101_01100_000_00110_0110011;    // R-Type: ADD x6, x12, x13
        // rom[25] = 32'b0100000_00110_00101_000_10100_0110011;    // R-Type: SUB x20, x5, x6
        // rom[26] = 32'b000000000000_10100_000_01010_0010011;     // I-Type: ADDI x10, x20, 0
        // rom[27] = 32'b0000000_00000_00010_011_10100_0000011;    // L-Type: LW x20, offset(x2)
        // rom[28] = 32'b0000000_01000_00010_011_00110_0000011;    // L-Type: LW x6, offset(x2)
        // rom[29] = 32'b0000000_10000_00010_011_00101_0000011;    // L-Type: LW x5, offset(x2)
        // rom[30] = 32'b000000011000_00010_000_00010_0010011;     // I-Type: ADDI x2, x2, offset
        // rom[31] = 32'b000000000000_11111_000_11110_1100111;     // I-Type: JALR x31, x30, offset


        // // // R타입 롬시나리오
        // //          _funcn7 _rs2  _rs1  _f3 _rd   _opcode;           -R_Type
        // rom[0]  = 32'b0100000_00001_00010_000_00001_0110011;  //     SUB x1, x2, x1
        // rom[1]  = 32'b0000000_00001_00010_000_00010_0110011;  //     ADD x2, x2, x1
        // rom[2]  = 32'b0100000_00001_00001_000_00010_0110011;  //     SUB x2, x1, x1
        // rom[3]  = 32'b0000000_00001_00001_001_00010_0110011;  //     SLL x2, x1, x1
        // rom[4]  = 32'b0000000_00001_00001_101_00010_0110011;  //     SRL x2, x1, x1
        // rom[5]  = 32'b0100000_00001_00001_101_00010_0110011;  //     SRA x2, x1, x1
        // rom[6]  = 32'b0000000_00001_00010_010_00010_0110011;  //     SLT x2, x2, x1
        // rom[7]  = 32'b0000000_00001_00010_011_00010_0110011;  //     SLTU x2, x2, x1
        // rom[8]  = 32'b0000000_00001_00000_100_00010_0110011;  //     XOR x2, x2, x0
        // rom[9]  = 32'b0000000_00001_00010_110_00010_0110011;  //     OR x2, x2, x1
        // rom[10] = 32'b0000000_00001_00010_111_00010_0110011;  //     AND x2, x2, x1

        // // // I타입 롬시나리오
        // //          _funcn7 _rs2  _rs1  _f3 _rd   _opcode;           -R_Type
        // rom[0] = 32'b0100000_00001_00010_000_00001_0110011;  //      SUB x1, x2, x1
        // //          _imm[11:0]    _rs1  _f3 _rd   _opcode;           -I_Type
        // rom[1] = 32'b000000000001_00010_000_00010_0010011;  //       ADDI x2, x2, 1
        // rom[2] = 32'b000000000001_00010_010_00010_0010011;  //       SLTI x2, x2, 1
        // rom[3] = 32'b000000000001_00010_011_00010_0010011;  //       SLTIU x2, x2, 1
        // rom[4] = 32'b000000000001_00010_100_00010_0010011;  //       XORI x2, x2, 1
        // rom[5] = 32'b000000000001_00010_110_00010_0010011;  //       ORI x2, x2, 1
        // rom[6] = 32'b000000000001_00010_111_00010_0010011;  //       ANDI x2, x2, 1
        // rom[7] = 32'b000000000001_00001_001_00010_0010011;  //       SLLI x2, x1, 1
        // rom[8] = 32'b000000000001_00001_101_00010_0010011;  //       SRLI x2, x1, 1
        // rom[9] = 32'b010000000001_00001_101_00010_0010011;  //       SRAI x2, x1, 1

        // // // S, L타입 롬시나리오
        // //          _imm7   _rs2  _rs1  _f3 _imm5   _opcode;     S_Type
        // rom[0] = 32'b0000000_11111_00000_010_01000_0100011; //   SW x2, 8(x0)
        // //          _imm7   _imm5 _rs1  _f3 _rd   _opcode;       L_Type
        // rom[1] = 32'b0000000_01000_00000_010_00010_0000011; //   LW x6, 2(x0)

        // //B타입 롬시나리오: imm동작 검증1 romAddr 변화를 확인. 
        // //          _imm    _rs2  _rs1  _f3 _imm  _opcode;           -B_Type
        // rom[0] = 32'b0000000_00001_00001_000_01000_1100011; //       BEQ x1, x1, 8
        // rom[1] = 32'b0000000_00001_00001_000_01000_1100011; //       BEQ x1, x1, 8 (ignored)
        // rom[2] = 32'b0000000_00010_00001_000_01000_1100011; //       BEQ x1, x2, 8
        // rom[3] = 32'b0000000_00010_00001_000_01000_1100011; //       BEQ x1, x2, 8 (FALSE)
        // rom[4] = 32'b0000000_00001_00001_000_01000_1100011; //       BEQ x1, x1, 8 (TRUE)

        // // // LU,AU타입 롬시나리오
        // //           imm20               _rd   _opcode;              -XUI_Type
        // rom[0] = 32'b00000000000000000001_00001_0110111;  //         LUI x1, 1
        // rom[1] = 32'b00000000000000000001_00001_0110111;  //         LUI x1, 1
        // rom[2] = 32'b00000000000000000001_00010_0010111;  //         AUIPC x2, 1

        // // // J타입 롬시나리오
        // //          _imm      842           _rd   _opcode;           -J_Type
        // rom[0] = 32'b0_0000000100_0_00000000_00011_1101111;  //      JAL x3, 4
        // // //       _funcn7 _rs2  _rs1  _f3 _rd   _opcode;           -R_Type
        // rom[1] = 32'b0000000_00001_00010_000_00010_0110011;  //      ADD x2, x2, x1
        // //          _imm         _rs1  _000 _rd   _opcode;           -JL_Type
        // rom[2] = 32'b000000000000_00011_000_00100_1100111;  //       JALR x4, x3, 0
        // // //       _funcn7 _rs2  _rs1  _f3 _rd   _opcode;           -R_Type
        // rom[4] = 32'b0000000_01101_00010_000_00100_0110011;  //      ADD x4, x2, x13





        // // B타입 롬시나리오: 조건식 검증 alu 출력을 확인   
        // //          _imm7   _rs2  _rs1  _f3 _imm5 _opcode;       B_Type
        // rom[0] = 32'b0000000_00001_00001_000_00010_1100011; //   BEQ rs1 == shamt; 1
        // rom[1] = 32'b0000000_00010_00001_000_00010_1100011; //   BEQ rs1 == shamt; 0

        // rom[2] = 32'b0000000_00001_00001_001_00010_1100011; //   BNE rs1 != shamt; 0
        // rom[3] = 32'b0000000_00010_00001_001_00010_1100011; //   BNE rs1 != shamt; 1

        // rom[4] = 32'b0000000_00001_00001_100_00010_1100011; //   BLT rs1 < shamt; 0
        // rom[5] = 32'b0000000_00010_00001_100_00010_1100011; //   BLT rs1 < shamt; 1
        // rom[6] = 32'b0000000_00001_00010_100_00010_1100011; //   BLT rs1 < shamt; 0

        // rom[7] = 32'b0000000_00001_00001_101_00010_1100011; //   BGE rs1 >= shamt; 1
        // rom[8] = 32'b0000000_00010_00001_101_00010_1100011; //   BGE rs1 >= shamt; 0
        // rom[9] = 32'b0000000_00001_00010_101_00010_1100011; //   BGE rs1 >= shamt; 1

        // rom[10] = 32'b0000000_00001_00001_110_00010_1100011; //  BLTU rs1 < shamt; (U)
        // rom[11] = 32'b0000000_00010_00001_110_00010_1100011; //  BLTU rs1 < shamt; (U)
        // rom[12] = 32'b0000000_00001_00010_110_00010_1100011; //  BLTU rs1 < shamt; (U)

        // rom[13] = 32'b0000000_00001_00001_111_00010_1100011; //  BGEU rs1 >= shamt; (U)
        // rom[14] = 32'b0000000_00010_00001_111_00010_1100011; //  BGEU rs1 >= shamt; (U)
        // rom[15] = 32'b0000000_00001_00010_111_00010_1100011; //  BGEU rs1 >= shamt; (U)



        // // // B타입 롬시나리오
        // //rom[x]=32'b fucn7 _ rs2 _ rs1 _f3 _ rd  _opcode; // R-Type
        // rom[0] = 32'b0000000_00001_00010_000_00100_0110011; // add x4, x2, x1
        // rom[1] = 32'b0100000_00001_00010_000_00101_0110011; // sub x5, x2, x1
        // //rom[x]=32'b imm7  _ rs2 _ rs1 _f3 _ imm5_ opcode; // B-Type
        // rom[2] = 32'b0000000_00010_00010_000_01100_1100011; // beq x2, x2, 12 //2는 PC의 주소
        // //rom[x]=32'b imm7  _ rs2 _ rs1 _f3 _ imm5_ opcode; // S-Type
        // rom[3] = 32'b0000000_00010_00000_010_01000_0100011; // sw x2, 8(x0); pass
        // //rom[x]=32'b imm12      _ rs1 _f3 _ rd  _ opcode; // L-Type
        // rom[4] = 32'b000000001000_00000_010_00011_0000011; // lw x3, 8(x0); pass
        // //rom[x]=32'b imm12      _ rs1 _f3 _ rd  _ opcode; // I-Type
        // rom[5] = 32'b000000000001_00000_000_00001_0010011; // addi x1, x0, 1;
        // rom[6] = 32'b000000000010_00001_001_00110_0010011; // slli x6, x1, 2;
    end
endmodule
